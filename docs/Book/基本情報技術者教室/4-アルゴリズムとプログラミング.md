# 4. アルゴリズムとプログラミング

## アルゴリズム

## 配列

## リスト

- 単方向リスト
- 双方向リスト
- 環状リスト

## キューとスタック

- キュー : FIFO
  - エンキュー
  - デキュー
- スタック : LIFO
  - プッシュ
  - ポップ

## 木構造

- 完全二分木
  - 根から葉までの深さがすべて等しい二分木
  - 深さ 1 だけ深い葉があり、左詰めなら OK
- 二分探索木
  - 左の子 < 親 < 右の子
- ヒープ木
  - 親 < 子 or 親 > 子の完全二分木
  - 根が最大値 or 最小値
- 逆ポーランド記法

## データの整列

- 基本交換法（バブルソート）
  - 隣り合うデータを比較して入れ替える
  - 比較回数 : $N(N-1)/2$
- 基本選択法
  - 列から最小値（最大値）を選択して入れ替える
  - 比較回数 : $N(N-1)/2$
- 基本挿入法（挿入ソート）
  - 整列済みの正しい位置にデータを挿入
  - 比較回数 : $N(N-1)/2$
- シェルソート
  - 決まったステップ数のデータを整列
- クイックソート
  - 基準値を決め、それより小さな値と大きな値のグループに振り分ける
- ヒープソート
  - 未整列部分を順序木に構成し、その最大値を取り出していく

## データの探索

- 線形探索法
  - 先頭から順番に探索
  - 番兵法 : 配列の最後尾に目的のデータを追加し、アルゴリズムを簡略化
  - 探索回数 : $(N+1)/2$
- 二分探索法
  - ソートされているデータを半分に限定していく
  - 探索回数 : $log_2N+1$
- ハッシュ探索法
  - データの格納先をあらかじめ決めておく。決め方はハッシュ関数
  - アドレスの衝突 : シノニム
  - 探索回数 : $1$

## 計算量

- 整列アルゴリズム
  - 基本交換法（バブルソート）: $O(n^2)$
  - 基本選択法 : $O(n^2)$
  - 基本挿入法（挿入ソート）: $O(n^2)$
- 探索アルゴリズム
  - 線形探索法 : $O(n)$
  - 二分探索法 : $O(log_2N)$
  - ハッシュ探索法 : $1$

## プログラムの属性

- 再配置可能（リロケータブル）: 主記憶のどこに配置しても実行可能
- 再入可能（リエントラント）: 複数のタスクが同時に使用可能
- 再使用可能（リユーザブル）: 再ロードしなくても使用可能
- 再帰的（リカーシブ）: 自分自身を呼び出す

## プログラム言語とマークアップ言語
